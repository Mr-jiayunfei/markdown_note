# C++

## 1 为什么要有初始化表？

1 如果没有在构造函数的初始值列表中显示地初始化成员，则该成员在构造函数体之前执行默认初始化（类类型的参数执行默认构造函数，普通类型的参数值为随机数），即先定义然后在构造函数体内赋值。

2 如果成员时const或者引用的话，必须将其初始化，因为引用和const变量必须初始化，不能先定义后赋值

3 当成员属于某种类类型且该类没有定义默认构造函数时（提供的构造函数均为有参构造函数），必须将这个成员初始化，因为无法对该成员的构造函数进行调用

注：如果一个构造函数为所有参数提供了默认实参，则它实际上也定义了默认构造函数

4 成员变量的初始化顺序由声明顺序决定，而与初始化表的顺序无关，最好令构造函数初始值的顺序与成员声明的顺序一致，最好令构造函数的参数作为成员的初始值，尽量避免使用其他成员初始化其他成员。

5 对象的创建过程：

（1）为对象分配内存

（2）调用成员子对象的构造函数(声明顺序)

（3）执行构造函数的代码



## 2 基类的析构函数为什么要设计为虚函数？

基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里他们的函数名不相同，看起来违背了重写的规则，但实际上编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。

子类的析构函数，会自动调用基类的析构函数，析构基类子对象。

注：析构函数的运作方式是最深层派生的那个子类其析构函数最先被调用，然后是其每一个基类的析构函数被调用，编译器会在子类的析构函数中创建一个对基类的析构函数的调用动作，所以基类的析构函数必须有定义。

基类的析构函数不会调用子类的析构函数，对一个指向子类对象的基类指针使用delete运算符，实际被执行的只有基类的析构函数，所释放的仅仅是基类子对象的动态资源，如果子类中有其它的动态资源分配将会形成内存泄露。

将基类的析构函数设计为虚函数，可利用多态调用子类的析构函数，进而调用基类的析构函数，释放所有资源。



## 3  智能指针有几种（shared_ptr,unique_ptr,weakPtr,autoptr）？每种智能指针的实现原理？每种智能指针的适用场景？为什么要有weakPtr？

智能指针是一个模板类，当离开作用域时，可以调用其析构函数自动释放内存资源。

智能指针有三种，shared_ptr，unique_ptr,weak_ptr。

shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象，weak_ptr是一种弱引用，指向shared_ptr所管理的对象。

shared_ptr的实现原理是在其内部维护了一个计数器（也是动态分配的内存），当我们拷贝一个shared_ptr时，计数器会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器会递减。

unique_ptr的实现原理是拷贝构造和赋值运算符都被删除（或者定义为私有），保留了移动构造和移动赋值函数。

weak_ptr的实现原理是在其内部维护了一个weak_count计数器。

autoptr是C++11之前实现的智能指针，现在已经基本弃用，有两个明显缺陷：第一个是使用delete操作符释放资源，如果是动态分配的数组对象，无法进行资源释放，第二个是两个指针不能指向相同的对象，当进行赋值操作时，会将另一个指针置为空值。

shared_ptr和weak_ptr拥有相同的基类，在这个基类中维护了引用计数基类_Ref_count_base，这个基类中有两个数据成员，_Uses和_Weaks，

```c++
_Atomic_counter_t _Uses;
_Atomic_counter_t _Weaks;
```

_Uses则是我们理解的引用计数，每有一个shared_ptr共享资源，_Uses就会加一，反之每一个shared_ptr析构，_Uses就会减一，当_Uses变为零时，意味着没有shared_ptr再占有资源，这个时候占有的资源会调用释放操作。但是并不能直接销毁引用计数对象，因为可能有弱引用还绑定到引用计数对象上。

而_Weaks就是weak_ptr追踪资源的计数器，每有一个weak_ptr追踪资源，_Weaks就会加一，反之每一个weak_ptr析构时，_Weaks就会减一，当_Weaks变为零时，意味着没有weak_ptr再追踪资源，这时会销毁引用计数对象。（可使用VS21017查看智能指针的实现源码）

三种智能指针使用C++的简单实现代码参考如下：

https://github.com/Mr-jiayunfei/code_learn/blob/main/STL/implement_SmartPtr/main.cpp



weak_ptr的使用场景

weak_ptr只能从shared_ptr对象构建。

weak_ptr并不影响动态对象的生命周期，即其存在与否并不影响对象的引用计数器。当weak_ptr所指向的对象因为shared_ptr计数器为0而被释放后，那么weak_ptr的lock方法将返回空。

weak_ptr并没有重载operator->和operator *操作符，因此不可直接通过weak_ptr使用对象。

提供了expired()与lock()成员函数，前者用于判断weak_ptr指向的对象是否已被销毁，后者返回其所指对象的shared_ptr智能指针(对象销毁时返回”空“shared_ptr)，如果返回shared_ptr，那么计数器会加1.

`std::weak_ptr`是解决悬空指针问题的一种很好的方法。仅通过使用原始指针，不知道所引用的数据是否已被释放。

相反，通过`std::shared_ptr`管理数据并提供`std::weak_ptr`给用户，用户可以通过调用`expired()`或来检查数据的有效性`lock()`。

weak_ptr可以解决shared_ptr的循环引用问题



## 4 虚函数的实现原理

虚函数表指针和虚函数表是C++实现多态的核心机制，理解vtbl和vptr的原理是理解C++对象模型的重要前提。
 class里面method分为两类：virtual 和non-virtual。非虚函数在编译器编译是静态绑定的，所谓静态绑定，就是编译器直接生成JMP汇编代码，对象在调用的时候直接跳转到JMP汇编代码执行，既然是汇编代码，那么就是不能在运行时更改的了；虚函数的实现是通过虚函数表，虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址，通过虚函数表在调用的时候才最终确定调用的是哪一个函数，这个就是动态绑定。

![img](https://i.loli.net/2021/04/13/zYtX8ZRkHnES31l.png)



![image-20210413225253856](https://i.loli.net/2021/04/13/DX5PJxjtwqRgbsG.png)



 通过观察和测试，我们发现了以下几点问题：

1. 派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员。
2. 基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重写的Derive::Func1，所以**虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖**。重写是语法的叫法，覆盖是原理层的叫法。
3. 另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会放进虚表。
4. 虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。
5. 总结一下派生类的虚表生成： a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。

典型面试题

虚函数存在哪的？虚表存在哪的？ 答：**虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中**。另外 **对象中存的不是虚表，存的是虚表指针**。



class的内部有一个virtual函数，其对象的首个地址就是vptr，指向虚函数表，虚函数表是连续的内存空间，也就是说，可以通过类似数组的计算，就可以取到多个虚函数的地址，还有一点，虚函数的顺序和其声明的顺序是一直的。



![img](https://i.loli.net/2021/04/13/wnD1SeUoLdYy9Iv.png)

> 怎么理解动态绑定和静态绑定，一般来说，对于类成员函数（不论是静态还是非静态的成员函数）都不需要创建一个在运行时的函数表来保存，他们直接被编译器编译成汇编代码，这就是所谓的静态绑定；所谓动态绑定就是对象在被创建的时候，在它运行的时候，其所携带的虚函数表，决定了需要调用的函数，也就是说，程序在编译完之后是不知道的，要在运行时才能决定到底是调用哪一个函数。这就是所谓的静态绑定和动态绑定。
>  参考: [C++this指针-百度百科](https://link.jianshu.com?t=http://baike.baidu.com/link?url=Yzd4GPwMhepMPfjjoAiQ6ZJgVNhLJ3QwjXoJzmcFMlh7JgI1nAt7iD7gyTqO-5IXHTNRPb1bs9njP_KdktnLvw2iXxTmOKJsZ9Sy3FifIoS_rCLVJIJtg2M9Oj8heK3m)

动态绑定需要三个条件同时成立：

> 1 指针调用
>  2 up-cast (有向上转型，父类指针指向子类对象)
>  3 调用的是虚函数

通过两张图看看汇编代码：



![img](https://i.loli.net/2021/04/13/uiEthp35kI9NwoX.png)

a.vfunc1()调用虚函数，那么a调用的是A的虚函数，还是B的虚函数？对象调用不会发生动态绑定，只有指针调用才会发生动态绑定。120行下面发生的call是汇编指令，call后面是一个地址，也就是函数编译完成之后的地址了。

再看第二张：

![img](https://i.loli.net/2021/04/13/9P2CpwAIElTNyRZ.png)

动态绑定

up-cast、指针调用、虚函数三个条件都满足动态调用，call指令后面不再是静态绑定简单的地址，翻译成C语言大概就是`(*(p->vptr)[n](p))`，通过虚函数表来调用函数。

参考链接：

https://cloud.tencent.com/developer/article/1688427

## 5 构造函数为什么不能声明为虚函数

虚函数需要依赖对象中指向类的虚函数表的指针，而这个指针是在构造函数中初始化的(这个工作是编译器做的，对程序员来说是透明的)，如果构造函数是虚函数的话，那么在调用构造函数的时候，而此时虚函数表指针并未初始化完成，这就会引起错误。





# 操作系统



# 网络

# 数据库